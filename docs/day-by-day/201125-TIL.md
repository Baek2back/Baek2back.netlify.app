# 함수의 형태

## 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)라 하며, 다시 호출하는 것은 불가능하다.

즉시 실행 함수는 함수 이름이 없는 익명 함수를 사용하는 것이 일반적이며, 기명 함수를 사용할 수도 있지만 그룹 연산자 `()` 내의 기명 함수의 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자가 되므로 즉시 실행 함수를 다시 호출하는 것이 불가능함에는 변함 없다.

```javascript
(function foo() {
  var a = 3;
  var b = 5;
  return a * b;
})();

foo(); // ReferenceError: foo is not defined
```

즉시 실행 함수는 반드시 그룹 연산자 `()`로 감싸야 하며, 기명 함수일때도 마찬가지이다. 그 이유는 자바스크립트 엔진이 암묵적으로 수행하는 ASI에 의해 함수 선언문이 끝나는 위치에 세미콜론이 암묵적으로 추가되기 때문이다.

```javascript
function foo() {}(); // => function foo() {};();
```

따라서 함수 선언문 뒤의 그룹 연산자 `()`에 피연산자가 없기 때문에 에러가 발생한다.

```javascript
(); // SyntaxError: Unexpected token ')'
```

그룹 연산자의 피연산자는 값으로 평가되므로 함수 선언을 그룹 연산자 내에서 하면 함수 리터럴로 평가되어 함수 객체가 된다.

```javascript
console.log(typeof (function f() {})); // function
console.log(typeof (function () {})); // function
```

따라서 그룹 연산자로 함수를 묶은 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서이다. `(function () {})`이 함수 객체를 반환하고 반환된 함수 객체를 호출하는 형태가 되는 것이다.

즉시 실행 함수 역시 일반 함수처럼 값을 반환하거나 인수를 전달하는 것이 가능하다.

```javascript
var res = (function () {
  return 3;
})();

console.log(res); // 3

res = (function (a, b) {
  return a * b;
})(3, 5);

console.log(res); // 15
```

따라서 즉시 실행 함수 내에 코드를 모아 두면 혹시 발생할 수 있는 변수나 함수 이름의 충돌을 방지할 수 있게 된다.

## 재귀 함수

함수가 자기 자신을 호출하는 것을 재귀 호출(recursive call)이라 하며 재귀 함수(recursive function)는 자기 자신을 호출하는 행위를 수행하는 함수를 의미한다.

중요한 점은 함수 내부에서 자기 자신을 호출할 때 사용한 식별자는 함수 몸체 내부에서만 유효한 **함수 이름**이다. 다만 함수 표현식으로 정의한 함수 내부에서는 함수 이름은 물론 함수를 가리키는 식별자로도 자기 자신을 재귀 호출할 수 있다. 단, 함수 외부에서 함수를 호출할 때는 반드시 함수를 가리키는 식별자로 해야 한다.

```javascript
var factorial = function foo(n) {
  console.log(factorial === foo); // true
  return n === 1 ? 1 : n * factorial(n - 1);
  // or
  return n === 1 ? 1 : n * foo(n - 1);
};

console.log(factorial(5));
console.log(foo(5)); // (X) ReferenceError: foo is not defined
```

## 중첩 함수

함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 하며, 중첩 함수를 포함하는 함수를 외부 함수라 한다. 일반적으로 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.

```javascript
function outer() {
  var x = 1;
  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); // 3
  }
  inner();
}
outer();
```

ES6 이전에는 함수 선언문의 경우 코드의 최상위 또는 다른 함수 내부에서만 정의할 수 있었으나 ES6부터는 `if` 문이나 `for` 문 등의 코드 블록 내에서도 정의할 수 있다. 즉, 문이 위치할 수 있는 문맥이라면 어디든지 가능하다.

단, 호이스팅으로 인해 혼란이 가중될 수 있으므로 `if` 문이나 `for` 문 등의 코드 블록에서 함수 선언문을 이용하여 함수를 정의하는 것은 바람직하지 않다.

## 콜백 함수

함수 중에서 반복하는 일은 변하지 않고 공통적이지만 반복하면서 하는 일의 내용이 다른 경우(함수의 일부분만 다른 경우)에도 매번 함수를 새롭게 정의해야 하는 문제가 있다. 이러한 문제는 함수를 합성하는 것으로 해결할 수 있는데, 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직만 추상화하여 함수 외부에서 내부로 전달하는 것이다.

```javascript
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}

var logAll = function (i) {
  console.log(i);
};

repeat(5, logAll); // 0 1 2 3 4

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

repeat(5, logOdds); // 1 3
```

위의 `repeat` 함수는 경우에 따라 변경되는 일을 함수 `f`로 추상화하였고 이는 외부에서 제공된다. 자바스크립트에서 함수는 일급 객체이므로 값으로 평가될 수 있고, 이는 함수의 매개변수로 전달될 수 있다는 것을 의미한다.

이처럼 **함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며, 매개변수를 통해 콜백 함수를 전달받은 함수를 고차 함수라 한다.**

중첩 함수와 비슷하게 고차 함수에 전달되어 헬퍼 함수의 역할을 하지만, 중첩 함수는 고정되어 있어 교체가 어려운 반면 콜백 함수는 함수 외부에서 주입되기 때문에 자유롭게 교체가 가능하다. 따라서 **고차 함수는 콜백 함수를 자신의 일부분으로 합성하는 것이다.**

**고차 함수는 전달받은 콜백 함수의 호출 시점을 결정하며, 이때 필요에 따라 콜백 함수에 인수를 전달할 수 있다.** 따라서 고차 함수에 콜백 함수를 전달할 때는 콜백 함수를 호출한 결과가 아닌 함수 자체를 전달해야 한다.

!> 모든 콜백 함수가 고차 함수에 의해 호출되는 것은 아니며, 예를 들어 `setTimeout` 함수의 콜백 함수는 `setTimeout` 함수가 호출하지 않는다.

일반적으로 콜백 함수가 고차 함수 내부에서만 호출된다면 익명 함수 리터럴로 정의하면서 바로 전달한다.

다만 콜백 함수로 전달된 함수 리터럴은 고차 함수 자체가 호출될 때마다 평가되어 함수 객체를 생성하기 때문에 고차 함수가 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 함수 참조를 고차 함수에 전달하는 편이 효율적이다.

```javascript
var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 고차 함수에 함수 참조를 전달한다.
repeat(5, logOdds); // 1 3
```

콜백 함수는 비동기 처리(이벤트 처리, Ajax 통신, Timer 함수 등)에 활용되는 중요한 패턴이다.

```javascript
document.getElementById('myButton').addEventListener('click', function () {
  console.log('clicked!');
});

setTimeout(function () {
  console.log('1초 경과');
}, 1000);
```

## 순수 함수와 비순수 함수

> 순수 함수

- 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
- 외부 상태에 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 반환 값을 만든다.

> 비순수 함수

- 함수의 외부 상태에 의존하며 외부 상태에 따라 반환 값이 달라진다.
- 외부 상태에 의존·변경 (부수효과 존재) → 비순수 함수
- 외부 상태에 의존·변경 X (부수효과 X) → 순수 함수
- 함수 내부에서 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 객체를 전달받은 경우 비순수 함수이다.

### 함수형 프로그래밍

- 순수 함수와 보조 함수의 조합을 통해 부수 효과를 최소화하여 불변성을 지향하는 패러다임.
- 로직 내에 존재하는 조건문과 반복문을 제거해서 복잡성을 해결
- 변수 사용 억제 및 생명 주기 최소화를 통해 상태 변경을 피하고 오류를 최소화하는 것을 목표로 함.

?> 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 하여 가독성을 해치고, 변수의 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있기 때문이다.
