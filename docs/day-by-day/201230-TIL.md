# 이벤트

## 이벤트 드리븐 프로그래밍

만약 애플리케이션이 특정 타입의 이벤트에 반응하여 어떤 일을 수행하게끔 하고 싶다면 해당 이벤트가 발생했을 때 호출될 함수를 브라우저에게 알려 호출을 위임한다. 이때 이벤트가 발생했을 때 호출될 함수를 **이벤트 핸들러**라 하고, 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 **이벤트 핸들러 등록**이라 한다.

이벤트와 이벤트 핸들러를 통해 사용자와 애플리케이션은 상호작용(interaction)할 수 있다. 이처럼 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 **이벤트 드리븐 프로그래밍**이라 한다.

## 이벤트 핸들러 등록

### 이벤트 핸들러 어트리뷰트 방식

```html
<!DOCTYPE html>
<html>
  <body>
    <button onclick="sayHi('Lee')">Click me!</button>
    <script>
      function sayHi(name) {
        console.log(`Hi! ${name}.`);
      }
    </script>
  </body>
</html>
```

!> 이벤트 핸들러 어트리뷰트 값으로 함수 참조가 아닌 함수 호출문 등의 **문을 할당**한다는 점에 주의하자. 이벤트 핸들러 프로퍼티 방식에서는 DOM 노드의 이벤트 핸들러 프로퍼티에 함수 참조를 할당한다.

함수 호출문을 등록하면 함수 호출문의 평가 결과가 이벤트 핸들러로 등록된다. 함수를 반환하는 고차 함수 호출문을 이벤트 핸들러로 등록한다면 문제가 없겠지만 함수가 아닌 값을 반환하는 함수 호출문을 이벤트 핸들러로 등록하면 브라우저가 이벤트 핸들러를 호출할 수 없다.

?> **이벤트 핸들러 어트리뷰트 값은 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미한다.**

`onclick="sayHi('Lee')"` 어트리뷰트는 다음과 같은 함수를 암묵적으로 생성하고, 이벤트 핸들러 어트리뷰트 이름과 동일한 키 `onclick` 이벤트 핸들러 프로퍼티에 할당한다.

```javascript
function onclick(event) {
  sayHi('Lee');
}
```

이와 같이 동작하는 이유는 이벤트 핸들러에 인수를 전달하기 위해서인데, 만약 함수 참조를 할당해야 한다면 인수를 전달하기 곤란했을 것이다. 결국 이때 할당한 문자열은 암묵적으로 생성되는 이벤트 핸들러의 함수 몸체이므로 여러 개의 문을 할당하는 것이 가능하다.

```html
<button onclick="console.log('Hi! '); console.log('Lee');">Click</button>
```

### 이벤트 핸들러 프로퍼티 방식

`window` 객체와 `Document`,`HTMLElement` 타입의 DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있다.

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector('button');

      // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
      $button.onclick = function () {
        console.log('button click');
      };
    </script>
  </body>
</html>
```

이벤트 핸들러를 등록하기 위해서는 이벤트를 발생시킬 객체인 이벤트 타깃(event target)과 이벤트 종류를 나타내는 문자열인 이벤트 타입(event type) 그리고 이벤트 핸들러를 지정해야 한다.

이벤트 핸들러는 대부분 이벤트를 발생시킬 이벤트 타깃에 바인딩하지만, 반드시 그렇게 해야하는 것은 아니다.

?> 이벤트 핸들러는 이벤트 타깃 또는 전파된 이벤트를 캐치할 DOM 노드 객체에 바인딩한다.

앞서 살펴본 이벤트 핸들러 어트리뷰트 방식 역시 DOM 노드 객체의 이벤트 핸들러 프로퍼티로 변환되므로 결과적으로는 이벤트 핸들러 프로퍼티 방식과 동일하다 할 수 있지만 이벤트 핸들러 프로퍼티 방식은 HTML과 자바스크립트가 뒤섞이는 문제를 해결할 수 있다.

!> 하지만 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩할 수 있다는 점은 단점이다.

### addEventListener 메서드 방식

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector('button');

      // 이벤트 핸들러 프로퍼티 방식
      // $button.onclick = function () {
      //   console.log('button click');
      // };

      // addEventListener 메서드 방식
      $button.addEventListener('click', function () {
        console.log('button click');
      });
    </script>
  </body>
</html>
```

이벤트 핸들러 프로퍼티 방식은 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩하지만 `addEventListener` 메서드에는 이벤트 핸들러를 인수로 전달한다. 이때 `addEventListener` 메서드 방식은 이벤트 핸들러 프로퍼티에 바인딩된 이벤트 핸들러에 아무런 영향을 주지 않고, 이벤트 핸들러 프로퍼티 방식은 동일한 이벤트에 대해 하나 이상의 이벤트 핸들러를 등록할 수 없지만, `addEventListener` 메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있으며 등록된 순서대로 호출된다.

## 이벤트 핸들러 제거

`addEventListener` 메서드로 등록한 이벤트 핸들러를 제거하려면 `EventTarget.prototype.removeEventListener` 메서드를 사용하면 된다. 단, `addEventListener` 메서드에 전달한 인수와 일치해야 제거 된다.

```html
<!DOCTYPE html>
<html>
  <body>
    <button>Click me!</button>
    <script>
      const $button = document.querySelector('button');

      const handleClick = () => console.log('button click');

      // 이벤트 핸들러 등록
      $button.addEventListener('click', handleClick);

      // 이벤트 핸들러 제거
      // addEventListener 메서드에 전달한 인수와 removeEventListener 메서드에
      // 전달한 인수가 일치하지 않으면 이벤트 핸들러가 제거되지 않는다.
      $button.removeEventListener('click', handleClick, true); // 실패
      $button.removeEventListener('click', handleClick); // 성공
    </script>
  </body>
</html>
```

이때 무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없으므로 이벤트 핸들러를 제거하려면 이벤트 핸들러의 참조를 변수나 자료구조에 저장하고 있어야 한다.

!> 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러를 제거하려면 이벤트 핸들러 프로퍼티에 `null`을 할당해야 한다.

## 이벤트 객체

이벤트가 발생하면 이벤트에 대한 정보를 담고 있는 이벤트 객체가 동적으로 생성되며, **생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.**

!> 이벤트 핸들러 어트리뷰트 방식의 경우 이벤트 객체를 전달받으려면 첫 번째 매개변수 이름이 반드시 `event`여야 한다. 이벤트 핸들러 어트리뷰트 값은 암묵적으로 생성되는 이벤트 핸들러의 함수 몸체를 의미하기 때문이다.

## 이벤트 전파

DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li id="apple">Apple</li>
      <!-- click -->
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
  </body>
</html>
```

ul 요소의 두 번째 자식 요소 li를 클릭하면 클릭 이벤트가 발생하는데, 이때 생성된 이벤트 객체는 **이벤트를 발생시킨 DOM 요소인 이벤트 타깃(event target)을 중심으로 DOM 트리를 통해 전파된다.** 이벤트 전파는 전파 방향에 따라 다음과 같이 3단계로 구분할 수 있다.

![](https://poiemaweb.com/assets/fs-images/40-8.png)

> **캡처링 단계**
>
> 이벤트가 상위 요소에서 하위 요소 방향으로 전파

> **타깃 단계**
>
> 이벤트가 이벤트 타깃에 도달

> **버블링 단계**
>
> 이벤트가 하위 요소에서 상위 요소 방향으로 전파

다음 코드에서 ul 요소에 이벤트 핸들러를 바인딩하였으므로 `event.currentTarget`은 ul 요소이고, 이벤트를 발생시킨 `event.target`은 li 요소이다.

```html
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script>
      const $fruits = document.getElementById('fruits');

      // #fruits 요소의 하위 요소인 li 요소를 클릭한 경우
      $fruits.addEventListener('click', e => {
        console.log(`이벤트 단계: ${e.eventPhase}`); // 3: 버블링 단계
        console.log(`이벤트 타깃: ${e.target}`); // [object HTMLLIElement]
        console.log(`커런트 타깃: ${e.currentTarget}`); // [object HTMLUListElement]
      });
    </script>
  </body>
</html>
```

이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계의 이벤트만 캐치할 수 있다. 만약 `addEventListener` 메서드의 인수를 조정하면 캡처링 단계의 이벤트도 캐치할 수 있다.

이처럼 **이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다.**

대부분의 이벤트는 캡처링과 버블링을 통해 전파되지만 다음 이벤트들은 버블링을 통해 전파되지 않는다. 이 이벤트들은 버블링을 통해 이벤트를 전파하는지 여부를 나타내는 이벤트 객체의 공통 프로퍼티 `event.bubbles`의 값이 모두 `false`다.

- 포커스 이벤트: focus/blur
- 리소스 이벤트: load/unload/abort/error
- 마우스 이벤트: mouseenter/mouseleave

따라서 만약 이벤트 타깃의 상위 요소에서 위의 이벤트를 캐치하려면 대체할 수 있는 이벤트들을 활용하자. 이 이벤트들은 버블링을 통해 전파된다. 따라서 캡처링 단계에서 이벤트를 캐치해야 할 경우는 거의 없다.

- 포커스 이벤트: focusin/focusout
- 마우스 이벤트: mouseover/mouseout

## 이벤트 위임

사용자가 li 요소를 클릭하면 선택된 li 요소에 active 클래스를 추가하는 예제를 살펴보자.

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      #fruits {
        display: flex;
        list-style-type: none;
        padding: 0;
      }
      #fruits li {
        width: 100px;
        cursor: pointer;
      }
      #fruits .active {
        color: red;
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <nav>
      <ul id="fruits">
        <li id="apple" class="active">Apple</li>
        <li id="banana">Banana</li>
        <li id="orange">Orange</li>
      </ul>
    </nav>
    <div>선택된 내비게이션 아이템: <em class="msg">apple</em></div>
    <script>
      const $fruits = document.getElementById('fruits');
      const $msg = document.querySelector('.msg');
      // 사용자 클릭에 의해 선택된 내비게이션 아이템(li 요소)에 active 클래스를 추가하고
      // 그 외의 모든 내비게이션 아이템의 active 클래스를 제거한다.
      function activate({ target }) {
        [...$fruits.children].forEach($fruit => {
          $fruit.classList.toggle('active', $fruit === target);
          $msg.textContent = target.id;
        });
      }
      // 모든 내비게이션 아이템(li 요소)에 이벤트 핸들러를 등록한다.
      document.getElementById('apple').onclick = activate;
      document.getElementById('banana').onclick = activate;
      document.getElementById('orange').onclick = activate;
    </script>
  </body>
</html>
```

모든 li 요소가 클릭 이벤트에 반응하도록 이벤트 핸들러를 모두 등록해준 것을 확인할 수 있다. 이때 li 요소가 무수히 많다면 그만큼의 DOM 요소에 이벤트 핸들러를 등록하므로 성능 저하와 유지보수성을 해치는 원인이 된다.

이벤트 위임은 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법으로, 이벤트는 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치가 가능하므로 동적으로 하위 DOM 요소를 추가하더라도 일일이 추가된 DOM 요소에 이벤트 핸들러를 등록할 필요가 없다.

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      #fruits {
        display: flex;
        list-style-type: none;
        padding: 0;
      }

      #fruits li {
        width: 100px;
        cursor: pointer;
      }

      #fruits .active {
        color: red;
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <nav>
      <ul id="fruits">
        <li id="apple" class="active">Apple</li>
        <li id="banana">Banana</li>
        <li id="orange">Orange</li>
      </ul>
    </nav>
    <div>선택된 내비게이션 아이템: <em class="msg">apple</em></div>
    <script>
      const $fruits = document.getElementById('fruits');
      const $msg = document.querySelector('.msg');

      // 사용자 클릭에 의해 선택된 내비게이션 아이템(li 요소)에 active 클래스를 추가하고
      // 그 외의 모든 내비게이션 아이템의 active 클래스를 제거한다.
      function activate({ target }) {
        // 이벤트를 발생시킨 요소(target)가 ul#fruits의 자식 요소가 아니라면 무시한다.
        if (!target.matches('#fruits > li')) return;

        [...$fruits.children].forEach($fruit => {
          $fruit.classList.toggle('active', $fruit === target);
          $msg.textContent = target.id;
        });
      }

      // 이벤트 위임: 상위 요소(ul#fruits)는 하위 요소의 이벤트를 캐치할 수 있다.
      $fruits.onclick = activate;
    </script>
  </body>
</html>
```

이벤트 위임을 통해 하위 DOM 요소에서 발생한 이벤트를 처리할 때 상위 요소에 이벤트 핸들러를 등록하기 때문에 이벤트를 실제로 발생시킨 DOM 요소가 기대한 요소가 아닐 수 있다는 점이다. 위에서는 ul#fruits 요소에 바인딩된 이벤트 핸들러는 자신 포함 하위 요소 중에서 클릭 이벤트를 발생시킨 모든 DOM 요소에 반응하므로 이벤트에 반응이 필요한 DOM 요소에 한정하여 이벤트 핸들러가 실행되도록 이벤트 타깃을 검사할 필요가 있다.

