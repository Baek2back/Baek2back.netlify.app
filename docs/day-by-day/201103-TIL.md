# 비동기성 (Asynchrony)

**자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다.** 따라서 동시에 2개 이상의 함수를 동시에 실행할 수는 없다. 실행 컨텍스트 스택의 최상위 요소인 "현재 실행 중인 실행 컨텍스트"를 제외한 나머지 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크(task)들이다.

자바스크립트 엔진은 한 번에 하나의 태스크만 실행 할 수 있는 **싱글 스레드(Single thread)** 방식으로 동작한다. 싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에 시간이 걸리는 태스크를 실행하는 경우 블로킹(blocking)이 발생한다. 예를 들어 `setTimeout` 함수와 유사하게 일정 시간이 경과한 이후에 콜백 함수를 호출하는 `sleep` 함수를 구현한다고 생각해보자.

```javascript
// sleep 함수는 일정 시간(delay)이 경과한 이후에 콜백 함수(func)를 호출한다.
function sleep(func, delay) {
  const delayUntil = Date.now() + delay;

  // 현재 시간에 delay를 더한 delayUntil이 현재 시간보다 작으면 반복한다.
  while (Date.now() < delayUntil);
  // 일정 시간(delay)이 경과한 이후에 콜백 함수(func)를 호출한다.
  func();
}

function foo() {
  console.log('foo');
}

function bar() {
  console.log('bar');
}

// sleep 함수는 3초 동안 대기하다가 콜백 함수(foo)를 실행할 것이다.
sleep(foo, 3 * 1000);
// bar 함수는 sleep 함수의 실행이 종료된 이후에 호출되므로 3초 이상 블로킹된다.
bar();

// (3초 경과 후) 'foo' → 'bar'
```

이처럼 현재 실행 중인 태스크가 종료될 때까지 다음에 실행될 태스크가 대기하는 방식을 **동기(synchronous) 처리**라고 한다. 동기 처리 방식은 태스크를 순차적으로 처리하므로 실행 순서가 보장된다는 장점이 있지만, 앞에 위치한 태스크가 종료될 때까지 뒤에 위치한 태스크들은 블로킹된다는 단점이 존재한다.

```javascript
function foo() {
  console.log('foo');
}

function bar() {
  console.log('bar');
}

// 타이머 함수 setTimeout은 일정 시간이 경과한 이후에 콜백 함수 foo를 호출한다.
// 타이머 함수 setTimeout은 bar 함수를 블로킹하지 않는다.
setTimeout(foo, 3 * 1000);
bar();
// 'bar' → (3초 경과 후) 'foo'
```

`setTimeout` 함수는 앞서 구현한 `sleep` 함수와 유사하게 특정 시간이 경과한 이후에 콜백 함수를 호출하지만 `setTimeout` 함수 이후에 위치한 태스크를 블로킹하지 않고 곧바로 실행한다는 차이가 존재한다. 이처럼 현재 실행 중인 태스크가 종료되지 않은 상태라 하더라도 다음 태스크를 곧바로 실행하는 방식을 **비동기(asynchronous) 처리**라고 한다. 비동기 처리 방식은 블로킹은 발생하지 않으나, 태스크의 실행 순서가 보장되지 않는다는 단점이 존재한다.

## 이벤트 루프 (Event Loop)

자바스크립트는 싱글 스레드로 동작하기 때문에 한 번에 하나의 태스크만 처리할 수 있다. 그러나 브라우저가 동작하는 것을 살펴보면 많은 태스크가 동시에 처리되는 것처럼 느껴진다.

예를 들어 이벤트를 처리하기도 하고, HTTP 요청을 통해 서버로부터 데이터를 가져오면서 화면에 렌더링을 진행하기도 한다. 이처럼 자바스크립트에서 동시성(concurrency)을 지원하는 것이 바로 **이벤트 루프**(event loop)다.

![event-loop](./201102-TIL/event-loop.png)

이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나로 구글의 V8 자바스크립트 엔진을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분하는 것이 가능하다.

> **콜 스택**(call stack)

- 실행 컨텍스트가 추가되고 제거되는 스택인 실행 컨텍스트 스택을 의미한다.
- 함수를 호출하면 해당 함수 실행 컨텍스트가 콜 스택에 푸시되며 순차적으로 실행된다. 자바스크립트 엔진은 단 하나의 콜 스택을 사용하기 때문에 최상위(현재 실행중인) 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떠한 태스크도 실행되지 않는다.

> **힙**(Heap)

- 객체가 저장되는 메모리 공간으로, 콜 스택을 구성하는 실행 컨텍스트는 힙에 저장되어 있는 객체를 참조한다.

콜 스택과 힙으로 구성되어 있는 자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다. **비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다.** 비동기 방식으로 동작하는 `setTimeout`의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js가 담당한다. 이를 위해서 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.

> **태스크 큐**(task queue/event queue/callback queue)

- `setTimeout`이나 `setInterval`과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역으로, 태스크 큐와 별도로 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로태스크 큐도 존재한다.

> **이벤트 루프**(event loop)

- 이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인하는 작업을 수행한다. 만약 **콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적(FIFO)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.** 이때 콜 스택으로 이동한 함수는 실행된다. 즉, 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작한다.

```javascript
// eventLoop는 큐(FIFO) 역할을 하는 배열이다.
var eventLoop = [];
var event;

// 무한 실행
while (true) {
  // Tick 발생!
  if (eventLoop.length > 0) {
    // 큐에 있는 다음 이벤트 조회
    event = eventLoop.shift();
    // 다음 이벤트를 실행
    try {
      event();
    } catch (err) {
      reportError(err);
    }
  }
}
```

위의 코드에서는 `while`로 무한 루프를 발생시키는데, 이 루프의 매 순회(iteration)을 틱(tick)이라 하고, 틱이 발생할 때마다 큐에 적재된 이벤트(콜백 함수)를 꺼내어 실행한다.  
`setTimeout()`은 콜백을 이벤트 루프 큐에 넣지 않는다. `setTimeout()`은 타이머를 설정하는 함수일 뿐이다. 타이머가 종료되면 환경(브라우저, Node.js)이 콜백 함수를 이벤트 루프에 삽입한 뒤 틱이 발생할 때 콜백 함수를 꺼내어 실행하게 되는 것이다.  
만약 이벤트 루프가 20개(혹은 그 이상)의 원소로 가득 차 있다고 생각해보자. FIFO 방식으로 동작하므로 어떠한 콜백 함수도 먼저 앞으로 가려하지 않고 자신의 차례가 돌아올 때까지 기다릴 것이다. 이러한 특성 때문에 `setTimeout()` 타이머가 완벽하게 정확한 타이밍으로 동작하지 않는 점이 설명된다. 적어도 지정한 시간(interval) 이전에는 콜백 함수가 실행되지 않을 것이라는 사실은 보장할 수 있지만 정확히 언제 실행될지는 이벤트 루프의 상태에 따라 달라지게 되는 것이다. 이벤트 루프에는 개발자가 작성한 프로그램 이외에 다른 이벤트도 삽입될 수 있기 때문이다.

그렇다면 브라우저 환경에서 다음 예제가 어떻게 동작할지 살펴보자.

```javascript
function foo() {
  console.log('foo');
}
function bar() {
  console.log('bar');
}
setTimeout(foo, 0); // 0초(실제로는 4ms) 후에 foo 함수가 호출된다.
bar();
// bar foo
```

1. 전역 코드가 평가되어 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시된다.
2. 전역 코드가 실행되면서 `setTimeout` 함수가 호출된다. 이때 `setTimeout` 함수의 함수 실행 컨텍스트가 생성되고 콜스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다. 브라우저의 Web API(호스트 객체)인 타이머 함수도 함수이므로 함수 실행 컨텍스트를 생성한다.
3. `setTimeout` 함수가 실행되면 콜백 함수를 호출 스케줄링하고 종료되어 콜 스택에서 제거된다. 이때 호출 스케줄링, 즉 타이머 설정과 타이머가 만료되면 콜백 함수를 태스크 큐에 푸시하는 것은 브라우저의 역할이다.
4. 다음 작업들은 브라우저가 수행하는 작업과 엔진이 수행하는 작업인데 이 작업들은 **병행적**으로 처리된다.

> **브라우저가 수행하는 작업**

브라우저는 타이머를 설정하고 타이머의 만료를 기다린다. 이후에 타이머가 만료되면 콜백 함수 `foo`가 태스크 큐에 푸시된다. 이때 지연 시간(delay)가 4ms 이하인 경우 최소 지연 시간 4ms가 지정된다. 따라서 **4ms 후에 콜백 함수 `foo`가 태스크 큐에 푸시되어 대기하게 된다.** 그러나 `setTimeout` 함수로 호출 스케줄링한 콜백 함수가 정확히 명시한 지연 시간 후에 호출된다는 보장은 할 수 없다. 지연 시간 이후에 콜백 함수가 태스크 큐에 푸시되어 대기하게 되지만 콜 스택이 비어있지 않다면 호출할 수 없으므로 약간의 시간차가 발생할 수 있다.

> **자바스크립트 엔진이 수행하는 작업**

`bar` 함수가 호출되어 `bar` 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다. 이후 `bar` 함수가 종료되면 콜 스택에서 제거된다. 이때 브라우저가 타이머를 설정한 후 4ms가 경과했다면 **`foo` 함수는 여전히 태스크 큐에서 대기 중인 상태일 것이다.**

5. 전역 코드 실행이 종료되고 전역 실행 컨텍스트가 콜 스택에서 제거된다. 따라서 콜 스택에 어떠한 실행 컨텍스트도 존재하지 않는 상태이다.
6. 이벤트 루프는 콜 스택이 비어 있음을 감지하고 태스크 큐에서 대기 중인 콜백 함수 `foo`가 이벤트 루프에 의해 콜 스택에 푸시된다. 따라서 콜백 함수 `foo`의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 되며 `foo` 함수가 종료되면 콜 스택에서 제거된다.

정리하면 **비동기 함수인 `setTimeout`의 콜백 함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면, 다시 말해 전역 코드 및 명시적으로 호출된 함수가 모두 종료되면 비로소 콜 스택에 푸시되어 실행되게 된다.**

여기서 싱글 스레드 방식으로 동작하는 것은 **브라우저가 아니라 브라우저에 내장된 자바스크립트 엔진**이라는 점에 주의해야 한다. 만약 모든 자바스크립트 코드가 자바스크립트 엔진 하에서 싱글 스레드 방식으로만 동작한다 하면 자바스크립트는 비동기로 동작할 수 없다. 즉, **자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작한다.**

예를 들어, `setTimeout` 함수의 모든 처리가 자바스크립트 엔진에서 싱글 스레드로만 수행된다고 가정해보자. 이때 `setTimeout` 함수의 호출 스케줄링을 위한 타이머 설정도 자바스크립트 엔진이 수행해야 하므로 대기 시간 동안 어떠한 태스크도 실행할 수 없을 것이다. 즉, `setTimeout` 함수의 타이머 설정까지 자바스크립트 엔진이 싱글 스레드 방식으로 처리해야 한다면 자바스크립트가 비동기 방식으로 동작하는 것은 절대로 불가능할 것이다.

브라우저는 자바스크립트 엔진 외에도 렌더링 엔진과 Web API를 제공한다. Web API는 ECMAScript 사양에 정의된 함수가 아니라 브라우저가 제공하는 API이며, DOM API와 타이머 함수, HTTP 요청(Ajax)과 같은 비동기 처리를 포함한다.

앞선 예제에서 살펴보았듯이 브라우저의 Web API인 `setTimeout` 함수가 호출되면 자바스크립트 엔진의 콜 스택에 푸시되어 실행된다. 그러나 타이머 설정과 타이머가 만료됬을 때 콜백 함수를 태스크 큐에 등록하는 작업은 엔진이 아닌 브라우저가 수행하게 된다. 이처럼 브라우저와 엔진이 협력하여 비동기 함수인 `setTimeout` 함수를 실행하는 것이다.

## 병렬 스레딩

비동기(async)와 병렬(parallel)은 일반적으로 유사하다고 알고 있지만 엄밀히 말하면 의미는 완전히 다르다. 비동기의 경우 '지금'과 '나중' 간의 간극에 관한 용어이고, 병렬은 동시에 일어나는 일들과 연관된다.

프로세스(process)와 스레드(thread)는 가장 많이 쓰이는 병렬 컴퓨팅(parallel) 수단으로, 별개의 프로세서(processor), 심지어는 물리적으로 분리된 컴퓨터에서도 독립적으로(때로는 동시에) 실행되며 여러 개의 스레드가 하나의 프로세스 메모리를 공유한다.

반면 이벤트 루프는 작업 단위로 나누어 순차적으로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할 수는 없다.

```javascript
function later() {
  answer = answer * 2;
  console.log('answer', answer);
}
```

`later()` 함수 전체 내용은 이벤트 루프 큐에서는 하나의 원소로 취급하므로 스레드 간섭이 발생하지 않는 싱글 스레드 환경에서는 위와 같은 함수가 여러 개 쌓여 있다 하더라도 문제가 발생하지 않는다. 하지만 하나의 프로그램에서 여러 스레드를 처리하는 병렬 시스템에선 예상치 못한 일이 발생할 수 있다.

```javascript
var a = 20;

function foo() {
  a = a + 1;
}

function bar() {
  a = a * 2;
}

ajax('http://some.url.1', foo);
ajax('http://some.url.2', bar);
```

자바스크립트 엔진은 싱글 스레드 환경에서 동작하므로 `foo() → bar()` 순서로 실행하면 결과는 42지만 반대로 `bar() → foo()` 순서로 실행되면 결과는 41이 된다.

같은 데이터를 공유하는 자바스크립트 이벤트의 병렬 실행 문제는 더 복잡하다. `foo()`와 `bar()`를 각각 실행하는 두 스레드가 있다고 가정해보자. 만약 정확히 동일한 시점에 두 스레드가 실행된다면 어떻게 될까?

> **thread 1** (X,Y는 임시 메모리 공간)

```javascript
foo():
  1. 'a' 값을 'X' 로 load한다.
  2. '1' 을 'Y' 에 저장한다.
  3. 'X' 와 'Y' 를 더하고 그 결과를 'X' 에 저장한다.
  4. 'X' 값을 'a' 에 저장한다.
```

> **thread 2** (X,Y는 임시 메모리 공간)

```javascript
bar():
  1. 'a' 값을 'X' 로 load한다.
  2. '2' 을 'Y' 에 저장한다.
  3. 'X' 와 'Y' 를 곱하고 그 결과를 'X' 에 저장한다.
  4. 'X' 값을 'a' 에 저장한다.
```

두 스레드가 병렬 상태로 실행되면 위와 같이 중간 단계에서 `X`와 `Y`라는 메모리 공간을 공유하는 문제가 발생한다. 그렇다면 `a`의 최종 상태는 어떻게 될까?

```javascript
[t1]-1. ('X'에서 'a'값을 읽어들인다. → '20')
[t2]-1. ('X'에서 'a'값을 읽어들인다. → '20')
[t1]-2. ('Y'에 '1'을 저장한다. → '1')
[t2]-2. ('Y'에 '2'을 저장한다. → '2')
[t1]-3. ('X'와 'Y'를 더하고 그 결과를 'X'에 저장한다. → '22')
[t1]-4. ('a'에 'X' 값을 저장한다. → '22')
[t2]-3. ('X'와 'Y'를 곱하고 그 결과를 'X'에 저장한다. → '44')
[t2]-4. ('a'에 'X' 값을 저장한다. → '44')
// a → 44

[t1]-1. ('X'에서 'a'값을 읽어들인다. → '20')
[t2]-1. ('X'에서 'a'값을 읽어들인다. → '20')
[t2]-2. ('Y'에 '2'을 저장한다. → '2')
[t1]-2. ('Y'에 '1'을 저장한다. → '1')
[t2]-3. ('X'와 'Y'를 곱하고 그 결과를 'X'에 저장한다. → '20')
[t1]-3. ('X'와 'Y'를 더하고 그 결과를 'X'에 저장한다. → '21')
[t1]-4. ('a'에 'X' 값을 저장한다. → '21')
[t2]-4. ('a'에 'X' 값을 저장한다. → '21')
// a → 21
```

이처럼 실행 순서에 따라 결과값이 다르게 나온다.

자바스크립트는 절대로 스레드 간에 데이터를 공유하지 않으므로 위와 같은 비결정성(Nondeterminism)은 문제가 되지 않는다. 하지만 그렇다고 해서 자바스크립트 프로그램이 항상 결정적(Deterministic)이란 소리는 아니다. 이전의 예제와 같이 `foo()`와 `bar()`의 실행 순서에 따라 다른 결과인 41과 42를 도출하기 때문이다.

### 완전-실행

자바스크립트는 싱글 스레드 하에서 동작하므로 `foo()` 또는 `bar()` 내부의 코드는 원자적(atomic)이다. 일단 `foo()`가 실행되면 해당 함수 전체 코드가 실행되고 나서야 `bar()` 함수가 실행된다는 의미이다. 이를 완전 실행(Run-to-Completion)이라 한다.

```javascript
/* 동기 방식으로 실행 */
var a = 1;
var b = 2;

/* 비동기 방식으로 실행*/
function foo() {
  a++;
  b = b * a;
  a = b + 3;
}

function bar() {
  b--;
  a = 8 + b;
  b = a * 2;
}

ajax('http://some.url.1', foo);
ajax('http://some.url.2', bar);
```

`foo()`와 `bar()` 함수 내부의 코드는 비동기 방식으로 동작하므로 먼저 실행한 함수가 종료될 때까지 다른 함수는 대기해야 한다.

먼저 `foo()`가 먼저 수행됬다고 가정해보자.

```javascript
var a = 1;
var b = 2;

// foo()
a++;
b = b * a;
a = b + 3;

// bar()
b--;
a = 8 + b;
b = a * 2;

a; // 11
b; // 22
```

그렇다면 이번에는 `bar()`가 먼저 실행됬다고 가정해보자.

```javascript
var a = 1;
var b = 2;

// bar()
b--;
a = 8 + b;
b = a * 2;

// foo()
a++;
b = b * a;
a = b + 3;

a; // 183
b; // 180
```

이처럼 동일한 코드에 대해서도 함수(이벤트)의 순서에 따라 다른 결과를 도출하므로 비결정적이라 할 수 있다. 물론 스레드처럼 표현식의 처리 순서 수준까지는 아니기 때문에 스레드보다는 결정적이라 할 수 있다.

자바스크립트에서는 함수 실행 순서에 따른 비결정성을 경합 조건(Race Condition)이라 한다.

## 동시성

### 상호 작용

어떤 프로그램 내에서 여러 개의 '프로세스'가 여러 이벤트를 동시에 인터리빙 할 때 각각의 프로세스 간에 연관된 작업이 있다면 스코프나 DOM을 통해 간접적으로 상호 작용을 하게 된다. 이때 경합 조건이 발생하지 않도록 잘 조율해주는 작업이 필요하다.

```javascript
var res = [];

function response(data) {
  res.push(data);
}

ajax('http://some.url.1', response);
ajax('http://some.url.2', response);
```

두 개의 프로세스 모두 AJAX 응답 처리를 하는 `response()` 함수를 호출하기 때문에 먼저 선발된 순으로 처리될 것이다.

개발자 입장에서는 `some.url.1`의 결과는 `res[0]`에 `some.url.2`의 결과는 `res[1]`에 담을 의도로 위와 같이 구현하였겠지만, 의도대로 실행될 때도 있지만 어느 쪽에 있는 URL 응답이 먼저 도착하는 지에 따라 결과는 뒤집힐 수도 있다.

> 일반적으로 처리하는 작업의 성격(DB 조회, 정적 파일 불러오기 등)을 보고 응답의 도착 순서를 예측하는 경우가 많은데 요청 서버가 동일하고 해당 서버가 특정 순서로 응답하도록 설정해놓았다 하더라도 브라우저에 어떤 순서로 응답이 도착할 지는 보장할 수 없으므로 주의해야 한다.

따라서 경합 조건을 해결하려면 상호 작용의 순서를 잘 조정해야 한다.

```javascript
var res = [];

function response(data) {
  if (data.url === 'http://some.url.1') {
    res[0] = data;
  } else if (data.url === 'http://some.url.2') {
    res[1] = data;
  }
}

ajax('http://some.url.1', response);
ajax('http://some.url.2', response);
```

이제는 어느 쪽 AJAX 응답이 먼저 오더라도 배열에 저장될 데이터의 순서를 지정할 수 있다. 간단한 조정만으로 경합 조건에 의한 비결정성을 해소한 사례이다.

```javascript
var a, b;

function foo(x) {
  a = x * 2;
  baz();
}

function bar(y) {
  b = y * 2;
  baz();
}

function baz() {
  console.log(a + b);
}

ajax('http://some.url.1', foo);
ajax('http://some.url.2', bar);
```

`foo()`나 `bar()` 중 어느 쪽이 먼저 실행되더라도 `baz()` 함수는 `a`나 `b` 중 하나는 여전히 `undefined`인 상태에서 호출된다. 그러나 두 번째 실행될 때는 `a`,`b` 값이 모두 존재하므로 정상적으로 동작할 것이다.

```javascript
var a, b;

function foo(x) {
  a = x * 2;
  if (a && b) {
    baz();
  }
}

function bar(y) {
  a = y * 2;
  if (a && b) {
    baz();
  }
}

...
```

`a && b` 조건을 이용하여 `baz()`의 호출 여부를 판단하는 형태를 예전부터 관문(Gate)라 칭해왔다. 둘 중 누가 일찍 도착할 지는 모르지만 둘 다 도착한 이후에야 관문이 열리는 형태이다.

위와 같은 형태 말고도 또 다른 해결 방법이 존재한다. 이번에는 경합이라 불리기도 하고, 간단히 말하면 선착순 한 명만 이기는 형태이다. 비결정성을 수용하는 조건으로 한 명의 승자만 선출하는 방식을 채택하는 것이다.

```javascript
var a;

function foo(x) {
  a = x * 2;
  baz();
}

function bar(x) {
  a = x / 2;
  baz();
}

function baz() {
  console.log(a);
}

ajax('http://some.url.1', foo);
ajax('http://some.url.2', bar);
```

위의 코드에서는 `foo()`나 `bar()` 둘 중 하나는 나중에 실행된 함수가 다른 함수가 할당한 값을 덮어쓸뿐만 아니라 `baz()`를 한 번 더 호출하게 되는 의도와는 다른 코드이다.

```javascript
var a;

function foo(x) {
  if (!a) {
    a = x * 2;
    baz();
  }
}

function bar(x) {
  if (!a) {
    a = x / 2;
    baz();
  }
}

function baz() {
  console.log(a);
}

ajax('http://some.url.1', foo);
ajax('http://some.url.2', bar);
```

위와 같이 수정하면 `foo()`,`bar()` 중 먼저 실행된 함수가 `!a` 조건을 통과하고 `a`를 `undefined`가 아닌 값으로 바꾸게 되므로 늦게 실행된 함수는 `!a` 조건을 통과하지 못하게 된다.

### 협동

협동 역시 동시성을 조정하는 다른 방안으로 스코프에서 값을 공유하는 식의 상호 작용에는 관심을 주지 않고, 실행 시간이 오래 걸리는 '프로세스'를 여러 단계/배치로 쪼개어 다른 '프로세스'도 각자의 작업을 이벤트 루프 큐에 인터리빙 하도록 하는 것이 목표이다.

예를 들어 아주 긴 리스트를 받아 값을 변환하는 AJAX 응답 처리기가 있다고 해보자.

```javascript
var res = [];

// AJAX 호출 결과 response()는 배열을 받는다.
function response(data) {
  // 기존 res 배열에 추가한다.
  res = res.concat(
    data.map(function (val) {
      return val * 2;
    })
  );
}

ajax('http://some.url.1', response);
ajax('http://some.url.2', response);
```

처음 `http://some.url.1` 호출 결과가 넘어오면 전체 리스트는 바로 `res`에 매핑된다. 리스트의 길이가 짧다면 큰 문제가 안되겠지만 리스트의 길이가 무척이나 길다면 처리 시간이 꽤 소요될 것이다. 따라서 이 '프로세스'를 실행하는 도중에 페이지는 그대로 멈춰버린다. `response()` 함수의 실행, UI 업데이트는 물론 스크롤링, 타이핑, 버튼 클릭 등의 사용자 이벤트 역시 먹통이 될 것이다.

따라서 이벤트 루프 큐를 독점하지 않는, 협동적인 시스템이 되도록 하려면 각 결과를 비동기로 처리하고 이벤트 루프에서 대기 중인 다른 이벤트와 함께 실행될 수 있게끔 만들어야 한다.

```javascript
var res = [];

// AJAX 호출 결과 response()는 배열을 받는다.
function response(data) {
  // 한 번에 1,000개씩 실행한다.
  var chunk = data.splice(0, 1000);
  res = res.concat(
    chunk.map(function (val) {
      return val * 2;
    })
  );

  // 처리할 프로세스가 남아있다면
  if (data.length > 0) {
    // 다음 작업을 비동기 스케줄링한다.
    setTimeout(function () {
      response(data);
    }, 0);
  }
}

ajax('http://some.url.1', response);
ajax('http://some.url.2', response);
```

위와 같이 수정하면 다음 작업을 처리해야 하기는 하지만 이벤트 루프 큐에 위치한 다른 이벤트도 처리할 수 있게 되므로 응답성이 좋은 페이지를 구축할 수 있을 것이다.

물론 이렇게 나뉜 '프로세스'들의 실행 순서까지 조정한 것은 아니기 때문에 `res` 배열에 어떤 순서로 결과가 저장될지 보장할 수는 없다. 순서가 중요한 경우라면 다른 기법을 끌어다 써야 한다.

위에서 사용한 `setTimeout(_, 0)`은 비동기 스케줄링 hack 중 하나로 해당 함수를 현재 이벤트 루프 큐의 맨 뒤에 위치시켜달라고 주문하는 것과 같다.

> `setTimeout(_, 0)`은 엄밀히 말하면 원소를 이벤트 루프 큐에 곧바로 삽입하는 것이 아니라 타이머가 다음 기회에 이벤트를 삽입하게 된다. 따라서 연속해서 두 번 `setTimeout(_, 0)`을 호출하더라도 그 순서대로 처리되리라고 보장할 수는 없다.

## 잡(Job)

'잡 큐(Job Queue)'는 ES6부터 이벤트 루프 큐에 새롭게 도입된 개념이다. 잡 큐는 이벤트 루프 큐에서 '매 틱의 끝자락에 매달려 있는 큐'라고 생각하면 이해하기 쉬울 것이다. '나중'에 처리할 작업이지만 다른 어떤 작업들보다 우선해서 처리해달라고 부탁하는 것과 비슷하다고 생각하면 된다.

비유하면 이벤트 루프 큐는 놀이공원에서 롤러코스터를 타고나서 한 번 더 타고 싶어 다시 대기열 맨 끝에서 기다리는 것이고 잡 큐는 롤러코스터에서 내린 직후 대기열 맨 앞에서 곧바로 다시 타는 것이다.

잡은 같은 큐 끝에 더 많은 잡을 추가할 수 있기 때문이 이론적으로는 '잡 루프(Job Loop)'가 무한정 반복되면서 프로그램이 다음 이벤트 틱으로 이동하지 못하도록 만들 수도 있다. 개념적으로는 프로그램에서 실행 시간이 긴 코드 혹은 무한 루프를 표현한 것과 유사하다고 생각하면 된다.

잡은 기본적으로 `setTimeout(_, 0)` 같은 Hack과 의도는 비슷하지만 처리 순서(나중에, 그러나 가급적 빨리)가 더 잘 정의되어 있고 순서가 확실히 보장되는 방향으로 구현되어 있다.

다음은 잡 스케줄링을 수행하는 `schedule()`이라는 API이다.

```javascript
console.log('A');

setTimeout(function () {
  console.log('B');
}, 0);

// 이론적인 Job API
schedule(function () {
  console.log('C');

  schedule(function () {
    console.log('D');
  });
});
```

위의 코드는 실행 결과가 `A B C D`일 것 같지만 실행 결과는 `A C D B`이다. 잡은 현재 이벤트 루프 틱의 끝에서 시작하지만 타이머는 가능하다면 다음 이벤트 루프 틱에서 실행하도록 스케줄링하기 때문이다.
